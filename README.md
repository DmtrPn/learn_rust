**Cargo:**
- Мы можем создать проект с помощью cargo new.
- можно собирать проект, используя команду cargo build,
- можно одновременно собирать и запускать проект одной командой cargo run,
- можно собрать проект для проверки ошибок с помощью cargo check, не тратя время на кодогенерацию исполняемого файла,
- cargo сохраняет результаты сборки не в директорию с исходным кодом, а в отдельный каталог target/debug.

Стандартные библиотеки
https://doc.rust-lang.org/std/index.html#modules


**Правила владения**

- У каждого значения в Rust есть владелец,
- У значения может быть только один владелец в один момент времени,
- Когда владелец покидает область видимости, значение удаляется.

Если мы хотим глубоко скопировать данные кучи String, а не только данные стека, мы можем использовать общий метод, называемый clone. Мы обсудим синтаксис методов в главе 5, но поскольку методы являются общей чертой многих языков программирования, вы, вероятно, уже встречались с ними.


**Ссылки**
- В один момент времени, может существовать либо одна изменяемая ссылка, либо любое количество неизменяемых ссылка,
- Все ссылки должны быть действительными



**Ошибки**
Память, которую использовала программа, должна быть очищена операционной системой. Если в вашем проекте нужно насколько это возможно сделать маленьким исполняемый файл, вы можете переключиться с варианта раскрутки стека на вариант прерывания при панике, добавьте panic = 'abort' в раздел [profile] вашего Cargo.toml файла. Например, если вы хотите прервать панику в режиме релиза, добавьте это:


[profile.release]
panic = 'abort'

оператор ? разрешено использовать только в функции, которая возвращает Result, Option или другой тип, реализующий FromResidual.


**Типажи**
Типаж сообщает компилятору Rust о функциональности, которой обладает определённый тип и которой он может поделиться с другими типами. Можно использовать типажи, чтобы определять общее поведение абстрактным способом. Мы можем использовать ограничение типажа (trait bounds) чтобы указать, что общим типом может быть любой тип, который имеет определённое поведение.

Примечание: Типажи похожи на функциональность часто называемую интерфейсами в других языках программирования, хотя и с некоторыми отличиями.

мы можем реализовать типаж для типа только в том случае, если хотя бы один из типажей типа является локальным для нашего крейта. 

